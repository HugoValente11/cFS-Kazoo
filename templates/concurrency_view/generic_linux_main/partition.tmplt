@@-- The up to date list of tags available for this template is available here:
@@-- https://taste.tuxfamily.org/wiki/index.php?title=Kazoo_Templates_Documentation#templates.2Fconcurrency_view.2Fsub.2Fpartition.tmplt
@@-- If you are using vim, go over the URL and pres gx in to follow the link
@@-- If you have no internet access you can also use (with vim) Ctrl-W-f or gf in vim to open the text doc:
@@-- $HOME/tool-inst/share/kazoo/doc/templates_concurrency_view_sub_partition.ascii
/* File generated by kazoo for TASTE - do not edit */
#include <cstdint>

@@IF@@ @_Coverage_@ = TRUE
#include <signal.h>
@@END_IF@@

#include <Lock.h>
#include <Queue.h>
#include <Request.h>
#include <Thread.h>
#include <Timer.h>
#include <StartBarrier.h>

#include <system_spec.h>

#include "@_LOWER:Name_@_interface.h"
#include "transport.h"

extern "C"
{
#include <Broker.h>
#include <DriverHelper.h>
@@IF@@ @_Coverage_@ = TRUE
#include <gcov.h>
#include <unistd.h>
@@END_IF@@
}

@@IF@@ @_Coverage_@ = TRUE
static void ctrl_c_handler()
{
    @@-- calling exit(0) does not stop the application, and
    @@-- therefore atexit is not called, so coverage data is
    @@-- not dumped. We can however do it manually and then
    @@-- force the application to close with _exit.
    __gcov_dump();
    _exit(0);
}
@@END_IF@@

@@TABLE@@
@@IF@@ @_Device_Language_@ = cpp
#include "drivers/@_Device_Driver_Names_@/@_Device_Driver_Names_@.h"
@@ELSIF@@ @_Device_Language_@ = c
#include "drivers/@_Device_Driver_Names_@/@_Device_Driver_Names_@.h"
@@ELSE@@
#error "Unsupported device implementation language @_Device_Language_@"
@@END_IF@@
@@END_TABLE@@

@@TABLE@@
#include "thread_@_LOWER:Thread_Names_@.h"
@@END_TABLE@@

@@TABLE@@
extern "C"
{
extern void init_@_LOWER:Bound_Functions_@(void);
}
@@END_TABLE@@

@@TABLE@@
static @_Device_Driver_Names_@_private_data @_Device_Names_@_data;
@@END_TABLE@@

driver_send_function bus_to_driver_send_function[SYSTEM_BUSES_NUMBER];
void* bus_to_driver_private_data[SYSTEM_BUSES_NUMBER];
deliver_function interface_to_deliver_function[INTERFACE_MAX_ID];

static void initializeDevices()
{
    for(int i = 0; i < SYSTEM_BUSES_NUMBER; ++i)
    {
        bus_to_driver_send_function[i] = nullptr;
        bus_to_driver_private_data[i] = nullptr;
    }

    // register send functions
@@TABLE@@
    bus_to_driver_send_function[BUS_@_UPPER:Device_Bus_Name_@] = @_Device_Send_Function_@;
    bus_to_driver_private_data[BUS_@_UPPER:Device_Bus_Name_@] = &@_Device_Names_@_data;
@@END_TABLE@@
    // initialize devices
@@TABLE@@
    @_Device_Init_@(&@_Device_Names_@_data,
                    BUS_@_UPPER:Device_Bus_Name_@,
                    DEVICE_@_UPPER:Node_Name_@_@_UPPER:Device_Names_@,
                    (@_REPLACE_ALL(-/_):Device_ASN1_Sort_@*)get_device_configuration(DEVICE_@_UPPER:Node_Name_@_@_UPPER:Device_Names_@),
                    (@_REPLACE_ALL(-/_):Device_ASN1_Sort_@*)get_remote_device_configuration(DEVICE_@_UPPER:Node_Name_@_@_UPPER:Device_Names_@));
@@END_TABLE@@
}

@@TABLE@@
taste::Lock @_LOWER:Bound_Functions_@_Mutex;
@@END_TABLE@@

@_Threads_@

// the main function
int main(void)
{
@@IF@@ @_Coverage_@ = TRUE
    signal(SIGINT, (__sighandler_t)ctrl_c_handler);
@@END_IF@@
    initializeDevices();

    initialize_transport();
    Broker_initialize();

@@TABLE@@
    init_@_LOWER:Bound_Functions_@();
@@END_TABLE@@

    taste::StartBarrier::initialize(@_Thread_Names'Length_@, &taste::Timer::initialize);

@@TABLE@@
    Initialize_Thread_@_LOWER:Thread_Names_@();
@@END_TABLE@@

@@TABLE@@
    Join_Thread_@_LOWER:Thread_Names_@();
@@END_TABLE@@
}
