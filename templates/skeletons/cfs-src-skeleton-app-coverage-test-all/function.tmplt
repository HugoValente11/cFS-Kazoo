/*
 * Includes
 */

#include "@_LOWER:Name_@_app_coveragetest_common.h"
#include "ut_@_LOWER:Name_@_app.h"

typedef struct
{
    uint16      ExpectedEvent;
    uint32      MatchCount;
    const char *ExpectedFormat;
} UT_CheckEvent_t;

/*
 * An example hook function to check for a specific event.
 */
static int32 UT_CheckEvent_Hook(void *UserObj, int32 StubRetcode, uint32 CallCount, const UT_StubContext_t *Context,
                                va_list va)
{
    UT_CheckEvent_t *State = UserObj;
    uint16           EventId;
    const char *     Spec;

    /*
     * The CFE_EVS_SendEvent stub passes the EventID as the
     * first context argument.
     */
    if (Context->ArgCount > 0)
    {
        EventId = UT_Hook_GetArgValueByName(Context, "EventID", uint16);
        if (EventId == State->ExpectedEvent)
        {
            if (State->ExpectedFormat != NULL)
            {
                Spec = UT_Hook_GetArgValueByName(Context, "Spec", const char *);
                if (Spec != NULL)
                {
                    /*
                     * Example of how to validate the full argument set.
                     * ------------------------------------------------
                     *
                     * If really desired one can call something like:
                     *
                     * char TestText[CFE_MISSION_EVS_MAX_MESSAGE_LENGTH];
                     * vsnprintf(TestText, sizeof(TestText), Spec, va);
                     *
                     * And then compare the output (TestText) to the expected fully-rendered string.
                     *
                     * NOTE: While this can be done, use with discretion - This isn't really
                     * verifying that the FSW code unit generated the correct event text,
                     * rather it is validating what the system snprintf() library function
                     * produces when passed the format string and args.
                     *
                     * This type of check has been demonstrated to make tests very fragile,
                     * because it is influenced by many factors outside the control of the
                     * test case.
                     *
                     * __This derived string is not an actual output of the unit under test__
                     */
                    if (strcmp(Spec, State->ExpectedFormat) == 0)
                    {
                        ++State->MatchCount;
                    }
                }
            }
            else
            {
                ++State->MatchCount;
            }
        }
    }

    return 0;
}

/*
 * Helper function to set up for event checking
 * This attaches the hook function to CFE_EVS_SendEvent
 */
static void UT_CheckEvent_Setup(UT_CheckEvent_t *Evt, uint16 ExpectedEvent, const char *ExpectedFormat)
{
    memset(Evt, 0, sizeof(*Evt));
    Evt->ExpectedEvent  = ExpectedEvent;
    Evt->ExpectedFormat = ExpectedFormat;
    UT_SetVaHookFunction(UT_KEY(CFE_EVS_SendEvent), UT_CheckEvent_Hook, Evt);
}

void Test_@_UPPER:Name_@_APP_Main(void)
{
    /*
     * Test Case For:
     * void @_UPPER:Name_@_APP_Main( void )
     */

    /*
     * @_UPPER:Name_@_APP_Main does not return a value,
     * but it has several internal decision points
     * that need to be exercised here.
     *
     * First call it in "nominal" mode where all
     * dependent calls should be successful by default.
     */
    @_UPPER:Name_@_APP_Main();
    UtAssert_True(UT_GetStubCount(UT_KEY(CFE_ES_ExitApp)) == 1, "CFE_ES_ExitApp() called");

    /* trigger a failure for each of the sub-calls,
     * and confirm a write to syslog for each.
     * Note that this count accumulates, because the status
     * is _not_ reset between these test cases. */


    // Fail on initialization
    // Can't stub APP_Init so fail inside init
    UT_SetDeferredRetcode(UT_KEY(CFE_EVS_Register), 1, CFE_EVS_INVALID_PARAMETER);
    @_UPPER:Name_@_APP_Main();
    UtAssert_True(@_UPPER:Name_@_APP_Data.RunStatus == CFE_ES_RunStatus_APP_ERROR,
                  "@_UPPER:Name_@_APP_Data.RunStatus (%lu) == CFE_ES_RunStatus_APP_ERROR",
                  (unsigned long)@_UPPER:Name_@_APP_Data.RunStatus);
    UtAssert_True(UT_GetStubCount(UT_KEY(CFE_ES_ExitApp)) == 2, "CFE_ES_ExitApp() called");
    
    // Enter while loop but fail on receive buffer
    UT_SetDeferredRetcode(UT_KEY(CFE_ES_RunLoop), 1, true);
    UT_SetDeferredRetcode(UT_KEY(CFE_SB_ReceiveBuffer), 1, CFE_SB_BAD_ARGUMENT);
    @_UPPER:Name_@_APP_Main();
    UtAssert_True(@_UPPER:Name_@_APP_Data.RunStatus == CFE_ES_RunStatus_APP_ERROR,
                  "@_UPPER:Name_@_APP_Data.RunStatus (%lu) == CFE_ES_RunStatus_APP_ERROR",
                  (unsigned long)@_UPPER:Name_@_APP_Data.RunStatus);
    UtAssert_True(UT_GetStubCount(UT_KEY(CFE_ES_ExitApp)) == 3, "CFE_ES_ExitApp() called");

    // Enter while loop and succeed on receive buffer
    UT_SetDeferredRetcode(UT_KEY(CFE_ES_RunLoop), 1, true);
    UT_SetDeferredRetcode(UT_KEY(CFE_SB_ReceiveBuffer), 1, CFE_SUCCESS);
    @_UPPER:Name_@_APP_Main();
    UtAssert_True(UT_GetStubCount(UT_KEY(CFE_ES_ExitApp)) == 4, "CFE_ES_ExitApp() called");

    // Never enter while loop
    UT_SetDeferredRetcode(UT_KEY(CFE_ES_RunLoop), 1, false);
    @_UPPER:Name_@_APP_Main();
    UtAssert_True(UT_GetStubCount(UT_KEY(CFE_ES_ExitApp)) == 5, "CFE_ES_ExitApp() called");


    // Fail on deleting pipe
    UT_SetDeferredRetcode(UT_KEY(CFE_SB_DeletePipe), 1, CFE_SB_BAD_ARGUMENT);
    @_UPPER:Name_@_APP_Main(); 
    UtAssert_True(UT_GetStubCount(UT_KEY(CFE_ES_WriteToSysLog)) == 2, "CFE_ES_WriteToSysLog() called");
    UtAssert_True(UT_GetStubCount(UT_KEY(CFE_ES_ExitApp)) == 6, "CFE_ES_ExitApp() called");


}


void Test_@_UPPER:Name_@_APP_Init(void)
{
    /*
     * Test Case For:
     * int32 @_UPPER:Name_@_APP_Init( void )
     */

    /* nominal case should return CFE_SUCCESS */
    UT_TEST_FUNCTION_RC(@_UPPER:Name_@_APP_Init(), CFE_SUCCESS);

    /* trigger a failure for each of the sub-calls,
     * and confirm a write to syslog for each.
     * Note that this count accumulates, because the status
     * is _not_ reset between these test cases. */

    // Fail on register events
    UT_SetDeferredRetcode(UT_KEY(CFE_EVS_Register), 1, CFE_EVS_INVALID_PARAMETER);
    UT_TEST_FUNCTION_RC(@_UPPER:Name_@_APP_Init(), CFE_EVS_INVALID_PARAMETER);
    UtAssert_True(UT_GetStubCount(UT_KEY(CFE_ES_WriteToSysLog)) == 1, "CFE_ES_WriteToSysLog() called");
    
    // Fail in initializing housekeeping
    UT_SetDeferredRetcode(UT_KEY(CFE_MSG_Init), 1, CFE_MSG_BAD_ARGUMENT);
    UT_TEST_FUNCTION_RC(@_UPPER:Name_@_APP_Init(), CFE_MSG_BAD_ARGUMENT);
    UtAssert_True(UT_GetStubCount(UT_KEY(CFE_ES_WriteToSysLog)) == 2, "CFE_ES_WriteToSysLog() called");

    // Fail in creating software bus pipe
    UT_SetDeferredRetcode(UT_KEY(CFE_SB_CreatePipe), 1, CFE_SB_BAD_ARGUMENT);
    UT_TEST_FUNCTION_RC(@_UPPER:Name_@_APP_Init(), CFE_SB_BAD_ARGUMENT);
    UtAssert_True(UT_GetStubCount(UT_KEY(CFE_ES_WriteToSysLog)) == 3, "CFE_ES_WriteToSysLog() called");

    // Fail in subscribing to house keeping requests
    UT_SetDeferredRetcode(UT_KEY(CFE_SB_Subscribe), 1, CFE_SB_BAD_ARGUMENT);
    UT_TEST_FUNCTION_RC(@_UPPER:Name_@_APP_Init(), CFE_SB_BAD_ARGUMENT);
    UtAssert_True(UT_GetStubCount(UT_KEY(CFE_ES_WriteToSysLog)) == 4, "CFE_ES_WriteToSysLog() called");

    // Fail in subscribing to ground command packets
    UT_SetDeferredRetcode(UT_KEY(CFE_SB_Subscribe), 2, CFE_SB_BAD_ARGUMENT);
    UT_TEST_FUNCTION_RC(@_UPPER:Name_@_APP_Init(), CFE_SB_BAD_ARGUMENT);
    UtAssert_True(UT_GetStubCount(UT_KEY(CFE_ES_WriteToSysLog)) == 5, "CFE_ES_WriteToSysLog() called");

}

void Test_@_UPPER:Name_@_FindAppId(void)
{
    // Fail on finding app
    // Initialize AppTable with non-matching names
    for (int i = 0; i < CFE_PLATFORM_ES_MAX_APPLICATIONS; i++)
    {
    strcpy(CFE_ES_Global.AppTable[i].AppName, "NON_MATCHING_APP");
    }
    @_UPPER:Name_@_APP_Data.AppId = CFE_ES_APPID_UNDEFINED;
    @_UPPER:Name_@_FindAppId();
    UtAssert_True(UT_GetStubCount(UT_KEY(CFE_ES_GetAppIDByName)) == 0, "CFE_ES_GetAppIDByName should not be called");
    UtAssert_True(@_UPPER:Name_@_APP_Data.AppId == CFE_ES_APPID_UNDEFINED, "@_UPPER:Name_@_APP_Data.AppId should remain unchanged");

    // Success on finding app
    // Initialize AppTable with matching names
    strcpy(CFE_ES_Global.AppTable[0].AppName, "@_UPPER:Name_@_APP");
    for (int i = 1; i < CFE_PLATFORM_ES_MAX_APPLICATIONS; i++)
    {
    strcpy(CFE_ES_Global.AppTable[i].AppName, "NON_MATCHING_APP");
    }
    UT_SetDeferredRetcode(UT_KEY(CFE_ES_GetAppIDByName), 1, CFE_SUCCESS);
    @_UPPER:Name_@_FindAppId();
    UtAssert_True(UT_GetStubCount(UT_KEY(CFE_ES_GetAppIDByName)) == 1, "CFE_ES_GetAppIDByName called");

    // Success on finding app but error on GetAppID
    strcpy(CFE_ES_Global.AppTable[0].AppName, "@_UPPER:Name_@_APP");
    for (int i = 1; i < CFE_PLATFORM_ES_MAX_APPLICATIONS; i++)
    {
    strcpy(CFE_ES_Global.AppTable[i].AppName, "NON_MATCHING_APP");
    }
    UT_SetDeferredRetcode(UT_KEY(CFE_ES_GetAppIDByName), 1, CFE_ES_BAD_ARGUMENT);
    @_UPPER:Name_@_FindAppId();
    UtAssert_True(UT_GetStubCount(UT_KEY(CFE_ES_WriteToSysLog)) == 1, "CFE_ES_WriteToSysLog() called");
    UtAssert_True(UT_GetStubCount(UT_KEY(CFE_ES_GetAppIDByName)) == 2, "CFE_ES_GetAppIDByName called");
}

@_Send_Messages_Functions_@
@_Receive_Messages_Functions_@

@@IF@@ @_DataStore_@ = "YES"
void Test_@_UPPER:Name_@_Datastore_Init(void)
{
    // Nominal case
    @_UPPER:Name_@_Datastore_Init();
    UtAssert_True(UT_GetStubCount(UT_KEY(CFE_ES_WriteToSysLog)) == 0, "CFE_ES_WriteToSysLog should not be called");

    // Error registering CDS
    UT_SetDeferredRetcode(UT_KEY(CFE_ES_RegisterCDS), 1, CFE_ES_BAD_ARGUMENT);
    @_UPPER:Name_@_Datastore_Init();
    UtAssert_True(UT_GetStubCount(UT_KEY(CFE_ES_WriteToSysLog)) == 1, "CFE_ES_WriteToSysLog called");

    // CDS Already exists and restore successfully
    UT_SetDeferredRetcode(UT_KEY(CFE_ES_RegisterCDS), 1, CFE_ES_CDS_ALREADY_EXISTS);
    UT_SetDeferredRetcode(UT_KEY(CFE_ES_RestoreFromCDS), 1, CFE_SUCCESS);
    @_UPPER:Name_@_Datastore_Init();
    UtAssert_True(UT_GetStubCount(UT_KEY(CFE_ES_WriteToSysLog)) == 2, "CFE_ES_WriteToSysLog called");

    // Error restoring CDS
    UT_SetDeferredRetcode(UT_KEY(CFE_ES_RegisterCDS), 1, CFE_ES_CDS_ALREADY_EXISTS);
    UT_SetDeferredRetcode(UT_KEY(CFE_ES_RestoreFromCDS), 1, CFE_ES_BAD_ARGUMENT);
    @_UPPER:Name_@_Datastore_Init();
    UtAssert_True(UT_GetStubCount(UT_KEY(CFE_ES_WriteToSysLog)) == 4, "CFE_ES_WriteToSysLog called");

}

void Test_@_UPPER:Name_@_Datastore_Store(void)
{
    int32 store = 42;
    // Nominal case
    @_UPPER:Name_@_Datastore_Store(&store);
    UtAssert_True(UT_GetStubCount(UT_KEY(CFE_ES_WriteToSysLog)) == 0, "CFE_ES_WriteToSysLog should not be called");

    // Fail on storing
    UT_SetDeferredRetcode(UT_KEY(CFE_ES_CopyToCDS), 1, CFE_ES_BAD_ARGUMENT);
    @_UPPER:Name_@_Datastore_Store(&store);
    UtAssert_True(UT_GetStubCount(UT_KEY(CFE_ES_WriteToSysLog)) == 1, "CFE_ES_WriteToSysLog called");

}

void Test_@_UPPER:Name_@_Datastore_User_Load(void)
{   
    uint8 expected_load[@_UPPER:Name_@_DATASTORE_SIZE];
    memset(expected_load, 42, @_UPPER:Name_@_DATASTORE_SIZE);
    uint8 actual_load[@_UPPER:Name_@_DATASTORE_SIZE];
    memset(actual_load, 0, @_UPPER:Name_@_DATASTORE_SIZE);


    // Nominal case
    UT_SetDataBuffer(UT_KEY(CFE_ES_RestoreFromCDS), &expected_load, sizeof(expected_load), false);
    @_UPPER:Name_@_Datastore_User_Load(&actual_load);
    UtAssert_True(UT_GetStubCount(UT_KEY(CFE_ES_WriteToSysLog)) == 0, "CFE_ES_WriteToSysLog should not be called");
    UtAssert_MemCmp(expected_load, actual_load, @_UPPER:Name_@_DATASTORE_SIZE, "Loaded from data store successfully");

    // Fail on restoring
    UT_SetDeferredRetcode(UT_KEY(CFE_ES_RestoreFromCDS), 1, CFE_ES_BAD_ARGUMENT);
    @_UPPER:Name_@_Datastore_User_Load(&actual_load);
    UtAssert_True(UT_GetStubCount(UT_KEY(CFE_ES_WriteToSysLog)) == 1, "CFE_ES_WriteToSysLog called");

}

@@END_IF@@

@_Component_Management_Functions_@

@_Send_Events_@


/*
 * Setup function prior to every test
 */
void @_Name_@_UT_Setup(void)
{
    UT_ResetState(0);
}

/*
 * Teardown function after every test
 */
void @_Name_@_UT_TearDown(void) {}

/*
 * Register the test cases to execute with the unit test tool
 */
void UtTest_Setup(void)
{
    ADD_TEST(@_UPPER:Name_@_APP_Init);
    ADD_TEST(@_UPPER:Name_@_APP_Main);
    ADD_TEST(@_UPPER:Name_@_FindAppId);
    @_Send_Messages_Init_@
@_Receive_Messages_Init_@
    @_Component_Management_Init_@
    @@IF@@ @_DataStore_@ = "YES"
    ADD_TEST(@_UPPER:Name_@_Datastore_Init);
    ADD_TEST(@_UPPER:Name_@_Datastore_Store);
    ADD_TEST(@_UPPER:Name_@_Datastore_User_Load);
    @@END_IF@@
    @_Event_Filters_@

}